#!/usr/bin/env python
# -*- coding: utf-8 -*-

import math
import argparse
import re

# Скрипт способен моделировать полёт низкоскоростных (Mach < 1) и низколетящих объектов.
# В соотвествии с законами механики и аэродинамики, в условиях земноподобной планеты.

# Примеры
# Взлёт пегаса с автопилотом:
# python pegasus-flight-simulation.py Пегас
# Взлёт пегаса с полезной нагрузкой:
# python pegasus-flight-simulation.py Пегас -w 300
# Поиск оптимальной (по дальности) скорости и угла атаки:
# python pegasus-flight-simulation.py -m Пегас
# python pegasus-flight-simulation.py -m Тяжёлый планёр
# Полёт пегаса с полезной нагрузкой в 300 килограмм, скоростью в 200 км/час и углом атаки в 15 градусов:
# python pegasus-flight-simulation.py -m Пегас -w 300 -s 200 -a 15

#-------------------------------------------------------------------------
# Известные баги:

# * Автопилот тупой как пробка. Взлетать умеет, но после взлёта угол атаки не меняет.
# * Сваливание. Сопротивление воздуха не учитывается (нужно ещё одну проекцию считать).
# * Для пикирования, впрочем, тоже. Хотя здесь проще подправить.

#-------------------------------------------------------------------------
# Общие переменные:

# Пока что константы:
# Температура в градусах цельсия:
AIR_TEMPERATURE = 20
# Плотность воздуха в кг/м² (нужно поставить зависимость от температуры и высоты)
AIR_DENSITY = 1.2
# Удельная теплоёмкость воздуха кДж/кг*К (зависит от температуры и давления)
AIR_HEAT_CAPACITY = 1.006
# Показатель адиабаты (зависит от температуры, пока что при 20°C)
AIR_HEAT_CAPACITY_RATIO = 1.4
# Молярная масса воздуха, кг/моль (зависит от состава атмосферы)
AIR_MOLAR_MASS = 0.029
# Динамическая вязкость воздуха в Па*с (зависит от температуры)
AIR_DYNAMIC_VISCOSITY = 0.000018
# Атмосферное давление в Паскалях (зависит от высоты и температуры)
ATMOSPHERIC_PRESSURE = 101325
# Источник пегасьей энергии в МДж/м³ (концентрация частиц должна падать с высотой)
AIR_MAGIC_ENERGY_MJ = 0.001

# Константы:
# Универсальная газовая постоянная
GAS_CONSTANT = 8.3144598
# Ускорение свободного падения
GRAVITATIONAL_ACCELERATION = 9.8
# Градусы цельсия в кельвины (0°C = 273.15K)
KELVIN_SCALE = 273.15
# Крылосила (в ваттах)
WINGPOWER = 30172

# Настройки модели:
# Летательный аппарат по умолчанию
SAMPLE = 'Пегас'
# КПД воздушно-реактивного двигателя
ENGINE_EFFICIENCY = 0.7
# Воздух для двигтеля при старте:
START_AIR_VOLUME = 4.4
# Какая часть попадающего на крылья воздуха идёт в рабочее вещество:
AIRFLOW_EFFICIENCY = 0.5
# Предельная скорость модели
MAX_SPEED = 500
# Число секундных циклов модели
PERIOD_SECOND = 60
# Коэффициент трения качения (пневматические шины по асфальту):
ROLLING_RESISTANCE_COEFFICIENT = 0.01
# Длина взлётно-посадочной полосы в метрах:
RUNWAY_LENGTH = 300

#-------------------------------------------------------------------------
# Летательные аппараты:

d_samples = {}

d_samples['Пегас'] = {
        'Масса аппарата (килограмм)':70,
        'Запас энергии (мегаджоулей)':45,
        'Объём двигателя (кубометров)':4.4,
        'Расход энергии (мегаджоулей)':0.5,
        'Размах крыла (метров)':4,
        'Хорда крыла (метров)':0.35,
        'Толщина крыла (метров)':0.35/10,
        'Несущая площадь крыла (квадратных метров)':1.4,
        'Фронтальная площадь крыла (квадратных метров)':(0.35/10)*4,
        'Длина фюзеляжа (метров)':1.43,
        'Ширина фюзеляжа (метров)':0.38,
        'Фронтальная площадь фюзеляжа (квадратных метров)':0.2,
        'Коэффициент лобового сопротивления фюзеляжа':0.5,
        # Ага, пони на колёсиках, потому что силу качения вычислить проще, а КПД сравним:
        'Радиус колеса шасси (метров)':0.15,
        'Дисколёт':False,
        # http://airfoiltools.com/images/airfoil/goe796-il_l.png
        # http://airfoiltools.com/airfoil/details?airfoil=goe796-il
        # http://airfoiltools.com/polar/details?polar=xf-goe796-il-1000000-n5
        'Поляра профиля крыла':{
            # Xfoil polar. Reynolds number fixed. Mach  number fixed
            # Polar key,xf-goe796-il-1000000-n5
            # Airfoil,goe796-il
            # Reynolds number,1000000
            # Ncrit,5
            # Mach,0
            # Max Cl/Cd,105.186
            # Max Cl/Cd alpha,4.75
            # Url,http://airfoiltools.com/polar/csv?polar=xf-goe796-il-1000000-n5
            # 
            # Alpha,Cl,Cd,Cdp,Cm,Top_Xtr,Bot_Xtr
            -14.500:(-0.7184,0.09505,0.09285,-0.0435,1.0000,0.0126),
            -14.250:(-0.7933,0.07833,0.07598,-0.0538,1.0000,0.0125),
            -14.000:(-0.9955,0.03555,0.03243,-0.0901,1.0000,0.0118),
            -13.750:(-1.0103,0.03312,0.02988,-0.0876,0.9999,0.0118),
            -13.500:(-0.9952,0.03086,0.02748,-0.0893,0.9950,0.0120),
            -13.250:(-0.9776,0.02911,0.02561,-0.0903,0.9899,0.0121),
            -13.000:(-0.9582,0.02761,0.02400,-0.0910,0.9853,0.0122),
            -12.750:(-0.9381,0.02629,0.02257,-0.0915,0.9810,0.0123),
            -12.500:(-0.9188,0.02509,0.02127,-0.0914,0.9755,0.0124),
            -12.000:(-0.8789,0.02298,0.01894,-0.0909,0.9651,0.0127),
            -11.750:(-0.8587,0.02205,0.01790,-0.0904,0.9598,0.0128),
            -11.500:(-0.8380,0.02120,0.01694,-0.0899,0.9547,0.0129),
            -11.250:(-0.8166,0.02044,0.01609,-0.0893,0.9491,0.0131),
            -11.000:(-0.7947,0.01974,0.01529,-0.0887,0.9440,0.0133),
            -10.750:(-0.7721,0.01905,0.01451,-0.0882,0.9390,0.0134),
            -10.500:(-0.7492,0.01841,0.01377,-0.0878,0.9332,0.0136),
            -10.250:(-0.7259,0.01782,0.01309,-0.0872,0.9279,0.0138),
            -10.000:(-0.7018,0.01723,0.01241,-0.0869,0.9227,0.0139),
            -9.750:(-0.6775,0.01670,0.01180,-0.0865,0.9166,0.0141),
            -9.500:(-0.6529,0.01622,0.01123,-0.0861,0.9109,0.0142),
            -9.250:(-0.6282,0.01566,0.01058,-0.0858,0.9043,0.0143),
            -9.000:(-0.6034,0.01514,0.00997,-0.0854,0.8977,0.0143),
            -8.750:(-0.5780,0.01465,0.00940,-0.0851,0.8909,0.0144),
            -8.500:(-0.5526,0.01419,0.00885,-0.0848,0.8830,0.0144),
            -8.250:(-0.5268,0.01375,0.00833,-0.0845,0.8749,0.0144),
            -8.000:(-0.5009,0.01335,0.00783,-0.0842,0.8664,0.0145),
            -7.750:(-0.4746,0.01295,0.00736,-0.0840,0.8571,0.0145),
            -7.500:(-0.4483,0.01259,0.00692,-0.0838,0.8471,0.0145),
            -7.250:(-0.4223,0.01217,0.00640,-0.0835,0.8357,0.0146),
            -7.000:(-0.3959,0.01178,0.00592,-0.0833,0.8236,0.0147),
            -6.750:(-0.3692,0.01144,0.00549,-0.0831,0.8118,0.0148),
            -6.500:(-0.3423,0.01114,0.00510,-0.0829,0.7998,0.0149),
            -6.250:(-0.3154,0.01087,0.00474,-0.0828,0.7876,0.0150),
            -6.000:(-0.2882,0.01062,0.00441,-0.0826,0.7757,0.0151),
            -5.750:(-0.2607,0.01039,0.00411,-0.0825,0.7654,0.0153),
            -5.500:(-0.2332,0.01018,0.00383,-0.0825,0.7565,0.0154),
            -5.250:(-0.2055,0.00997,0.00357,-0.0824,0.7476,0.0156),
            -5.000:(-0.1777,0.00979,0.00333,-0.0824,0.7395,0.0159),
            -4.750:(-0.1499,0.00963,0.00312,-0.0824,0.7308,0.0162),
            -4.500:(-0.1219,0.00948,0.00292,-0.0824,0.7226,0.0164),
            -4.250:(-0.0940,0.00936,0.00274,-0.0823,0.7136,0.0166),
            -4.000:(-0.0658,0.00923,0.00257,-0.0824,0.7061,0.0169),
            -3.750:(-0.0377,0.00912,0.00241,-0.0824,0.6992,0.0174),
            -3.500:(-0.0093,0.00901,0.00228,-0.0824,0.6933,0.0178),
            -3.250:(0.0190,0.00890,0.00214,-0.0825,0.6860,0.0192),
            -3.000:(0.0467,0.00869,0.00198,-0.0825,0.6794,0.0313),
            -2.750:(0.0750,0.00854,0.00187,-0.0826,0.6736,0.0427),
            -2.500:(0.1033,0.00846,0.00178,-0.0826,0.6672,0.0481),
            -2.250:(0.1318,0.00838,0.00170,-0.0827,0.6613,0.0529),
            -2.000:(0.1601,0.00830,0.00163,-0.0828,0.6542,0.0580),
            -1.750:(0.1883,0.00822,0.00156,-0.0829,0.6468,0.0684),
            -1.500:(0.2165,0.00811,0.00153,-0.0829,0.6383,0.0873),
            -1.250:(0.2449,0.00809,0.00150,-0.0830,0.6311,0.0948),
            -1.000:(0.2736,0.00806,0.00146,-0.0832,0.6248,0.0989),
            -0.500:(0.3306,0.00799,0.00141,-0.0834,0.6132,0.1106),
            -0.250:(0.3590,0.00795,0.00139,-0.0835,0.6063,0.1202),
            0.000:(0.3872,0.00794,0.00138,-0.0835,0.5963,0.1273),
            0.250:(0.4151,0.00794,0.00137,-0.0836,0.5828,0.1391),
            0.500:(0.4428,0.00791,0.00138,-0.0836,0.5701,0.1624),
            0.750:(0.4706,0.00786,0.00139,-0.0836,0.5590,0.1962),
            1.000:(0.4985,0.00782,0.00141,-0.0837,0.5481,0.2299),
            1.250:(0.5260,0.00778,0.00145,-0.0837,0.5355,0.2714),
            1.750:(0.5788,0.00755,0.00157,-0.0834,0.4970,0.4509),
            2.000:(0.6045,0.00750,0.00167,-0.0832,0.4719,0.5421),
            2.250:(0.6288,0.00739,0.00179,-0.0827,0.4441,0.6663),
            2.500:(0.6521,0.00734,0.00194,-0.0818,0.4149,0.7780),
            2.750:(0.6711,0.00719,0.00213,-0.0797,0.3927,0.9270),
            3.000:(0.7055,0.00741,0.00229,-0.0811,0.3718,0.9783),
            3.250:(0.7464,0.00765,0.00244,-0.0841,0.3551,0.9956),
            3.750:(0.8076,0.00797,0.00267,-0.0856,0.3354,1.0000),
            4.250:(0.8568,0.00829,0.00291,-0.0843,0.3178,1.0000),
            4.500:(0.8816,0.00847,0.00304,-0.0838,0.3105,1.0000),
            4.750:(0.9067,0.00862,0.00317,-0.0833,0.3014,1.0000),
            5.000:(0.9310,0.00886,0.00333,-0.0826,0.2858,1.0000),
            5.250:(0.9548,0.00913,0.00351,-0.0820,0.2673,1.0000),
            5.500:(0.9781,0.00945,0.00371,-0.0812,0.2422,1.0000),
            5.750:(0.9971,0.01009,0.00406,-0.0798,0.1915,1.0000),
            6.250:(1.0416,0.01088,0.00465,-0.0780,0.1550,1.0000),
            6.500:(1.0656,0.01115,0.00490,-0.0774,0.1477,1.0000),
            6.750:(1.0900,0.01138,0.00512,-0.0769,0.1422,1.0000),
            7.000:(1.1135,0.01167,0.00537,-0.0762,0.1350,1.0000),
            7.250:(1.1374,0.01192,0.00561,-0.0756,0.1278,1.0000),
            7.500:(1.1600,0.01226,0.00590,-0.0748,0.1180,1.0000),
            7.750:(1.1817,0.01264,0.00621,-0.0739,0.1048,1.0000),
            8.000:(1.2018,0.01313,0.00659,-0.0727,0.0880,1.0000),
            8.250:(1.2218,0.01359,0.00699,-0.0716,0.0761,1.0000),
            8.500:(1.2422,0.01401,0.00738,-0.0704,0.0685,1.0000),
            8.750:(1.2625,0.01440,0.00775,-0.0693,0.0626,1.0000),
            9.000:(1.2818,0.01482,0.00815,-0.0680,0.0568,1.0000),
            9.250:(1.2992,0.01525,0.00856,-0.0663,0.0515,1.0000),
            9.500:(1.3167,0.01567,0.00899,-0.0647,0.0476,1.0000),
            9.750:(1.3326,0.01620,0.00949,-0.0629,0.0414,1.0000),
            10.000:(1.3472,0.01682,0.01007,-0.0609,0.0335,1.0000),
            10.250:(1.3592,0.01761,0.01080,-0.0587,0.0236,1.0000),
            10.500:(1.3730,0.01833,0.01150,-0.0568,0.0193,1.0000),
            10.750:(1.3881,0.01898,0.01217,-0.0552,0.0171,1.0000),
            11.000:(1.4035,0.01962,0.01284,-0.0536,0.0158,1.0000),
            11.250:(1.4179,0.02034,0.01359,-0.0520,0.0146,1.0000),
            11.500:(1.4330,0.02104,0.01432,-0.0506,0.0138,1.0000),
            11.750:(1.4479,0.02175,0.01507,-0.0492,0.0129,1.0000),
            12.000:(1.4615,0.02257,0.01593,-0.0477,0.0119,1.0000),
            12.250:(1.4742,0.02348,0.01687,-0.0462,0.0109,1.0000),
            12.500:(1.4872,0.02438,0.01781,-0.0448,0.0099,1.0000),
            12.750:(1.4988,0.02541,0.01887,-0.0434,0.0088,1.0000),
            13.000:(1.5096,0.02654,0.02002,-0.0420,0.0083,1.0000),
            13.250:(1.5198,0.02773,0.02125,-0.0406,0.0079,1.0000),
            13.500:(1.5295,0.02899,0.02256,-0.0393,0.0077,1.0000),
            13.750:(1.5386,0.03036,0.02398,-0.0380,0.0074,1.0000),
            14.000:(1.5468,0.03182,0.02550,-0.0368,0.0071,1.0000),
            14.250:(1.5543,0.03338,0.02713,-0.0357,0.0069,1.0000),
            14.500:(1.5611,0.03505,0.02886,-0.0346,0.0067,1.0000),
            14.750:(1.5686,0.03671,0.03059,-0.0337,0.0066,1.0000),
            15.000:(1.5750,0.03848,0.03244,-0.0328,0.0065,1.0000),
            15.250:(1.5805,0.04039,0.03442,-0.0320,0.0063,1.0000),
            15.500:(1.5852,0.04244,0.03656,-0.0312,0.0062,1.0000),
            15.750:(1.5889,0.04465,0.03885,-0.0306,0.0060,1.0000),
            16.000:(1.5915,0.04701,0.04129,-0.0300,0.0058,1.0000),
            16.250:(1.5931,0.04954,0.04391,-0.0296,0.0057,1.0000),
            16.500:(1.5934,0.05229,0.04674,-0.0292,0.0055,1.0000),
            16.750:(1.5924,0.05527,0.04981,-0.0290,0.0054,1.0000),
            17.000:(1.5899,0.05847,0.05310,-0.0289,0.0052,1.0000),
            17.250:(1.5853,0.06202,0.05674,-0.0290,0.0051,1.0000),
            17.500:(1.5790,0.06593,0.06075,-0.0293,0.0050,1.0000),
            17.750:(1.5765,0.06941,0.06433,-0.0297,0.0049,1.0000),
            18.000:(1.5732,0.07306,0.06808,-0.0302,0.0048,1.0000),
            18.250:(1.5679,0.07706,0.07219,-0.0309,0.0048,1.0000),
            18.500:(1.5617,0.08128,0.07650,-0.0318,0.0047,1.0000),
            18.750:(1.5542,0.08577,0.08111,-0.0329,0.0046,1.0000),
            19.000:(1.5451,0.09058,0.08603,-0.0342,0.0045,1.0000),
            19.250:(1.5352,0.09557,0.09112,-0.0356,0.0044,1.0000),
            },
        }

d_samples['Тяжёлый планёр (18 пегасов)'] = {
        'Масса аппарата (килограмм)':5500+18*70,
        'Запас энергии (мегаджоулей)':45*18,
        'Объём двигателя (кубометров)':4.4*18,
        'Расход энергии (мегаджоулей)':0.5*18,
        'Размах крыла (метров)':29.4,
        'Хорда крыла (метров)':2.4,
        'Толщина крыла (метров)':2.4/10,
        'Несущая площадь крыла (квадратных метров)':200,
        'Фронтальная площадь крыла (квадратных метров)':(2.4/10)*29.4,
        'Длина фюзеляжа (метров)':1.43,
        'Ширина фюзеляжа (метров)':0.38,
        'Фронтальная площадь фюзеляжа (квадратных метров)':5.25,
        'Коэффициент лобового сопротивления фюзеляжа':0.1,
        'Радиус колеса шасси (метров)':0.3,
        'Дисколёт':False,
        # Сомнительно. Нужно найти подходящую поляру для триплана:
        'Поляра профиля крыла':{
            # Xfoil polar. Reynolds number fixed. Mach  number fixed
            # Polar key,xf-goe796-il-1000000-n5
            # Airfoil,goe796-il
            # Reynolds number,1000000
            # Ncrit,5
            # Mach,0
            # Max Cl/Cd,105.186
            # Max Cl/Cd alpha,4.75
            # Url,http://airfoiltools.com/polar/csv?polar=xf-goe796-il-1000000-n5
            # 
            # Alpha,Cl,Cd,Cdp,Cm,Top_Xtr,Bot_Xtr
            -14.500:(-0.7184,0.09505,0.09285,-0.0435,1.0000,0.0126),
            -14.250:(-0.7933,0.07833,0.07598,-0.0538,1.0000,0.0125),
            -14.000:(-0.9955,0.03555,0.03243,-0.0901,1.0000,0.0118),
            -13.750:(-1.0103,0.03312,0.02988,-0.0876,0.9999,0.0118),
            -13.500:(-0.9952,0.03086,0.02748,-0.0893,0.9950,0.0120),
            -13.250:(-0.9776,0.02911,0.02561,-0.0903,0.9899,0.0121),
            -13.000:(-0.9582,0.02761,0.02400,-0.0910,0.9853,0.0122),
            -12.750:(-0.9381,0.02629,0.02257,-0.0915,0.9810,0.0123),
            -12.500:(-0.9188,0.02509,0.02127,-0.0914,0.9755,0.0124),
            -12.000:(-0.8789,0.02298,0.01894,-0.0909,0.9651,0.0127),
            -11.750:(-0.8587,0.02205,0.01790,-0.0904,0.9598,0.0128),
            -11.500:(-0.8380,0.02120,0.01694,-0.0899,0.9547,0.0129),
            -11.250:(-0.8166,0.02044,0.01609,-0.0893,0.9491,0.0131),
            -11.000:(-0.7947,0.01974,0.01529,-0.0887,0.9440,0.0133),
            -10.750:(-0.7721,0.01905,0.01451,-0.0882,0.9390,0.0134),
            -10.500:(-0.7492,0.01841,0.01377,-0.0878,0.9332,0.0136),
            -10.250:(-0.7259,0.01782,0.01309,-0.0872,0.9279,0.0138),
            -10.000:(-0.7018,0.01723,0.01241,-0.0869,0.9227,0.0139),
            -9.750:(-0.6775,0.01670,0.01180,-0.0865,0.9166,0.0141),
            -9.500:(-0.6529,0.01622,0.01123,-0.0861,0.9109,0.0142),
            -9.250:(-0.6282,0.01566,0.01058,-0.0858,0.9043,0.0143),
            -9.000:(-0.6034,0.01514,0.00997,-0.0854,0.8977,0.0143),
            -8.750:(-0.5780,0.01465,0.00940,-0.0851,0.8909,0.0144),
            -8.500:(-0.5526,0.01419,0.00885,-0.0848,0.8830,0.0144),
            -8.250:(-0.5268,0.01375,0.00833,-0.0845,0.8749,0.0144),
            -8.000:(-0.5009,0.01335,0.00783,-0.0842,0.8664,0.0145),
            -7.750:(-0.4746,0.01295,0.00736,-0.0840,0.8571,0.0145),
            -7.500:(-0.4483,0.01259,0.00692,-0.0838,0.8471,0.0145),
            -7.250:(-0.4223,0.01217,0.00640,-0.0835,0.8357,0.0146),
            -7.000:(-0.3959,0.01178,0.00592,-0.0833,0.8236,0.0147),
            -6.750:(-0.3692,0.01144,0.00549,-0.0831,0.8118,0.0148),
            -6.500:(-0.3423,0.01114,0.00510,-0.0829,0.7998,0.0149),
            -6.250:(-0.3154,0.01087,0.00474,-0.0828,0.7876,0.0150),
            -6.000:(-0.2882,0.01062,0.00441,-0.0826,0.7757,0.0151),
            -5.750:(-0.2607,0.01039,0.00411,-0.0825,0.7654,0.0153),
            -5.500:(-0.2332,0.01018,0.00383,-0.0825,0.7565,0.0154),
            -5.250:(-0.2055,0.00997,0.00357,-0.0824,0.7476,0.0156),
            -5.000:(-0.1777,0.00979,0.00333,-0.0824,0.7395,0.0159),
            -4.750:(-0.1499,0.00963,0.00312,-0.0824,0.7308,0.0162),
            -4.500:(-0.1219,0.00948,0.00292,-0.0824,0.7226,0.0164),
            -4.250:(-0.0940,0.00936,0.00274,-0.0823,0.7136,0.0166),
            -4.000:(-0.0658,0.00923,0.00257,-0.0824,0.7061,0.0169),
            -3.750:(-0.0377,0.00912,0.00241,-0.0824,0.6992,0.0174),
            -3.500:(-0.0093,0.00901,0.00228,-0.0824,0.6933,0.0178),
            -3.250:(0.0190,0.00890,0.00214,-0.0825,0.6860,0.0192),
            -3.000:(0.0467,0.00869,0.00198,-0.0825,0.6794,0.0313),
            -2.750:(0.0750,0.00854,0.00187,-0.0826,0.6736,0.0427),
            -2.500:(0.1033,0.00846,0.00178,-0.0826,0.6672,0.0481),
            -2.250:(0.1318,0.00838,0.00170,-0.0827,0.6613,0.0529),
            -2.000:(0.1601,0.00830,0.00163,-0.0828,0.6542,0.0580),
            -1.750:(0.1883,0.00822,0.00156,-0.0829,0.6468,0.0684),
            -1.500:(0.2165,0.00811,0.00153,-0.0829,0.6383,0.0873),
            -1.250:(0.2449,0.00809,0.00150,-0.0830,0.6311,0.0948),
            -1.000:(0.2736,0.00806,0.00146,-0.0832,0.6248,0.0989),
            -0.500:(0.3306,0.00799,0.00141,-0.0834,0.6132,0.1106),
            -0.250:(0.3590,0.00795,0.00139,-0.0835,0.6063,0.1202),
            0.000:(0.3872,0.00794,0.00138,-0.0835,0.5963,0.1273),
            0.250:(0.4151,0.00794,0.00137,-0.0836,0.5828,0.1391),
            0.500:(0.4428,0.00791,0.00138,-0.0836,0.5701,0.1624),
            0.750:(0.4706,0.00786,0.00139,-0.0836,0.5590,0.1962),
            1.000:(0.4985,0.00782,0.00141,-0.0837,0.5481,0.2299),
            1.250:(0.5260,0.00778,0.00145,-0.0837,0.5355,0.2714),
            1.750:(0.5788,0.00755,0.00157,-0.0834,0.4970,0.4509),
            2.000:(0.6045,0.00750,0.00167,-0.0832,0.4719,0.5421),
            2.250:(0.6288,0.00739,0.00179,-0.0827,0.4441,0.6663),
            2.500:(0.6521,0.00734,0.00194,-0.0818,0.4149,0.7780),
            2.750:(0.6711,0.00719,0.00213,-0.0797,0.3927,0.9270),
            3.000:(0.7055,0.00741,0.00229,-0.0811,0.3718,0.9783),
            3.250:(0.7464,0.00765,0.00244,-0.0841,0.3551,0.9956),
            3.750:(0.8076,0.00797,0.00267,-0.0856,0.3354,1.0000),
            4.250:(0.8568,0.00829,0.00291,-0.0843,0.3178,1.0000),
            4.500:(0.8816,0.00847,0.00304,-0.0838,0.3105,1.0000),
            4.750:(0.9067,0.00862,0.00317,-0.0833,0.3014,1.0000),
            5.000:(0.9310,0.00886,0.00333,-0.0826,0.2858,1.0000),
            5.250:(0.9548,0.00913,0.00351,-0.0820,0.2673,1.0000),
            5.500:(0.9781,0.00945,0.00371,-0.0812,0.2422,1.0000),
            5.750:(0.9971,0.01009,0.00406,-0.0798,0.1915,1.0000),
            6.250:(1.0416,0.01088,0.00465,-0.0780,0.1550,1.0000),
            6.500:(1.0656,0.01115,0.00490,-0.0774,0.1477,1.0000),
            6.750:(1.0900,0.01138,0.00512,-0.0769,0.1422,1.0000),
            7.000:(1.1135,0.01167,0.00537,-0.0762,0.1350,1.0000),
            7.250:(1.1374,0.01192,0.00561,-0.0756,0.1278,1.0000),
            7.500:(1.1600,0.01226,0.00590,-0.0748,0.1180,1.0000),
            7.750:(1.1817,0.01264,0.00621,-0.0739,0.1048,1.0000),
            8.000:(1.2018,0.01313,0.00659,-0.0727,0.0880,1.0000),
            8.250:(1.2218,0.01359,0.00699,-0.0716,0.0761,1.0000),
            8.500:(1.2422,0.01401,0.00738,-0.0704,0.0685,1.0000),
            8.750:(1.2625,0.01440,0.00775,-0.0693,0.0626,1.0000),
            9.000:(1.2818,0.01482,0.00815,-0.0680,0.0568,1.0000),
            9.250:(1.2992,0.01525,0.00856,-0.0663,0.0515,1.0000),
            9.500:(1.3167,0.01567,0.00899,-0.0647,0.0476,1.0000),
            9.750:(1.3326,0.01620,0.00949,-0.0629,0.0414,1.0000),
            10.000:(1.3472,0.01682,0.01007,-0.0609,0.0335,1.0000),
            10.250:(1.3592,0.01761,0.01080,-0.0587,0.0236,1.0000),
            10.500:(1.3730,0.01833,0.01150,-0.0568,0.0193,1.0000),
            10.750:(1.3881,0.01898,0.01217,-0.0552,0.0171,1.0000),
            11.000:(1.4035,0.01962,0.01284,-0.0536,0.0158,1.0000),
            11.250:(1.4179,0.02034,0.01359,-0.0520,0.0146,1.0000),
            11.500:(1.4330,0.02104,0.01432,-0.0506,0.0138,1.0000),
            11.750:(1.4479,0.02175,0.01507,-0.0492,0.0129,1.0000),
            12.000:(1.4615,0.02257,0.01593,-0.0477,0.0119,1.0000),
            12.250:(1.4742,0.02348,0.01687,-0.0462,0.0109,1.0000),
            12.500:(1.4872,0.02438,0.01781,-0.0448,0.0099,1.0000),
            12.750:(1.4988,0.02541,0.01887,-0.0434,0.0088,1.0000),
            13.000:(1.5096,0.02654,0.02002,-0.0420,0.0083,1.0000),
            13.250:(1.5198,0.02773,0.02125,-0.0406,0.0079,1.0000),
            13.500:(1.5295,0.02899,0.02256,-0.0393,0.0077,1.0000),
            13.750:(1.5386,0.03036,0.02398,-0.0380,0.0074,1.0000),
            14.000:(1.5468,0.03182,0.02550,-0.0368,0.0071,1.0000),
            14.250:(1.5543,0.03338,0.02713,-0.0357,0.0069,1.0000),
            14.500:(1.5611,0.03505,0.02886,-0.0346,0.0067,1.0000),
            14.750:(1.5686,0.03671,0.03059,-0.0337,0.0066,1.0000),
            15.000:(1.5750,0.03848,0.03244,-0.0328,0.0065,1.0000),
            15.250:(1.5805,0.04039,0.03442,-0.0320,0.0063,1.0000),
            15.500:(1.5852,0.04244,0.03656,-0.0312,0.0062,1.0000),
            15.750:(1.5889,0.04465,0.03885,-0.0306,0.0060,1.0000),
            16.000:(1.5915,0.04701,0.04129,-0.0300,0.0058,1.0000),
            16.250:(1.5931,0.04954,0.04391,-0.0296,0.0057,1.0000),
            16.500:(1.5934,0.05229,0.04674,-0.0292,0.0055,1.0000),
            16.750:(1.5924,0.05527,0.04981,-0.0290,0.0054,1.0000),
            17.000:(1.5899,0.05847,0.05310,-0.0289,0.0052,1.0000),
            17.250:(1.5853,0.06202,0.05674,-0.0290,0.0051,1.0000),
            17.500:(1.5790,0.06593,0.06075,-0.0293,0.0050,1.0000),
            17.750:(1.5765,0.06941,0.06433,-0.0297,0.0049,1.0000),
            18.000:(1.5732,0.07306,0.06808,-0.0302,0.0048,1.0000),
            18.250:(1.5679,0.07706,0.07219,-0.0309,0.0048,1.0000),
            18.500:(1.5617,0.08128,0.07650,-0.0318,0.0047,1.0000),
            18.750:(1.5542,0.08577,0.08111,-0.0329,0.0046,1.0000),
            19.000:(1.5451,0.09058,0.08603,-0.0342,0.0045,1.0000),
            19.250:(1.5352,0.09557,0.09112,-0.0356,0.0044,1.0000),
            },
        }

#d_samples['Пегас на контуре левитации'] = {
#        # https://en.wikipedia.org/wiki/Sack_AS-6
#        # https://en.wikipedia.org/wiki/Flying_Pancake
#        # http://www.airwar.ru/enc/glider/diskoplan2.html
#        # http://www.aviajournal.com/arhiv/2003/12/06.html
#        'Масса аппарата (килограмм)':70,
#        'Рабочее вещество ВРД (килограмм)':5,
#        'Скорость реактивной струи (метров/секунду)':437,
#        'Энергии на сжатие рабочего вещества (мегаджоулей)':1.3,
#        'Запас энергии (мегаджоулей)':45,
#        'Коэффициент лобового сопротивления':0.1,
#        'Площадь фронтальной проекции (квадратных метров)':2,
#        'Размах крыла (метров)':4,
#        'Хорда крыла (метров)':4,
#        'Несущая площадь крыла (квадратных метров)':12.6,
#        'Поляра профиля крыла':{
#            # http://airfoiltools.com/images/airfoil/davis-corrected-il_l.png
#            # http://airfoiltools.com/airfoil/details?airfoil=davis-corrected-il
#            # http://www.aviajournal.com/arhiv/2003/12/06.html
#            # Alpha,Cl,Cd
#            0.0:(0.05,0.03),
#            2.0:(0.1,0.04),
#            4.0:(0.17,0.05),
#            6.0:(0.3,0.06),
#            8.0:(0.37,0.07),
#            10.0:(0.42,0.08),
#            12.0:(0.5,0.08),
#            14.0:(0.58,0.09),
#            16.0:(0.63,0.1),
#            18.0:(0.7,0.12),
#            20.0:(0.78,0.15),
#            22.0:(0.79,0.2),
#            24.0:(0.8,0.23),
#            26.0:(0.81,0.26),
#            28.0:(0.805,0.29),
#            30.0:(0.8,0.32),
#            },
#        }
#
#d_samples['Единорожья левитирующая сфера'] = {
#        'Масса аппарата (килограмм)':0.3,
#        'Рабочее вещество ВРД (килограмм)':0.005,
#        'Скорость реактивной струи (метров/секунду)':437,
#        'Энергии на сжатие рабочего вещества (мегаджоулей)':0.0013,
#        'Запас энергии (мегаджоулей)':0.0014,
#        'Коэффициент лобового сопротивления':0.47,
#        'Площадь фронтальной проекции (квадратных метров)':0.03,
#        'Размах крыла (метров)':0.01,
#        'Хорда крыла (метров)':0.01,
#        'Несущая площадь крыла (квадратных метров)':0.03,
#        'Поляра профиля крыла':{
#            # http://airfoiltools.com/images/airfoil/davis-corrected-il_l.png
#            # http://airfoiltools.com/airfoil/details?airfoil=davis-corrected-il
#            # http://www.aviajournal.com/arhiv/2003/12/06.html
#            # Alpha,Cl,Cd
#            0.0:(0.05,0.03),
#            2.0:(0.1,0.04),
#            4.0:(0.17,0.05),
#            6.0:(0.3,0.06),
#            8.0:(0.37,0.07),
#            10.0:(0.42,0.08),
#            12.0:(0.5,0.08),
#            14.0:(0.58,0.09),
#            16.0:(0.63,0.1),
#            18.0:(0.7,0.12),
#            20.0:(0.78,0.15),
#            22.0:(0.79,0.2),
#            24.0:(0.8,0.23),
#            26.0:(0.81,0.26),
#            28.0:(0.805,0.29),
#            30.0:(0.8,0.32),
#            },
#        }

#-------------------------------------------------------------------------
# Функции интерфейса:

def create_parser():
    """Список доступных параметров скрипта."""
    parser = argparse.ArgumentParser()
    parser.add_argument('sample',
                        nargs='*',
                        help='Летательный аппарат (в "кавычках")'
                        )
    parser.add_argument('-a', '--angle',
                        action='store', dest='angle', type=float,
                        help='Угол атаки (0-20)'
                        )
    parser.add_argument('-s', '--speed',
                        action='store', dest='speed', type=int,
                        help='Постоянная скорость (км/час)'
                        )
    parser.add_argument('-w', '--weight',
                        action='store', dest='weight', type=int,
                        help='Полезная нагрузка (кг)'
                        )
    parser.add_argument('-e', '--energy',
                        action='store_true', default='False',
                        help='Пополнение энергии в полёте'
                        )
    parser.add_argument('-m', '--model',
                        action='store_true', default='False',
                        help='Поиск оптимальных значений'
                        )
    return parser

def key_search (search_string, dict, silent=True):
    """Поиск нужного объекта в словаре, выбор по списку совпадений."""
    # Создаётся регистронезависимая поисковая строка:
    p = re.compile(search_string, re.I)
    # Создаём словарь совпадений:
    d_found = {}
    counter = 0
    # Поиск в словаре:
    for line in sorted(dict.keys()):
        line = str(line)
        if p.findall(line):
            d_found[counter] = line
            search_string = line
            counter = counter + 1
    # Если искомое не найдено, тогда выход:
    if not d_found:
        print(search_string)
        print('---Совпадений не найдено')
        exit(0)
    # Если найден один варинт, тогда его и выбираем:
    elif len(d_found) == 1:
        sample = d_found[0]
    elif silent is True:
        search_string = d_found[0]
        sample = search_string
    # Если несколько совпадений, тогда выбор по номеру:
    else:
        for key in d_found:
            print(key,d_found[key])
        string_number = input('---Найдено несколько совпадений (введите номер): ')
        search_string = d_found[int(string_number)]
        sample = search_string
        print('-----------------------------------------------------')
    return sample

#-------------------------------------------------------------------------
# Функции скрипта:

def f_triangle (side_b, angle_a, angle_b):
    """Сторона треугольника по двум углам и другой стороне.

    Теорема синусов:
    # http://www-formula.ru/lengthpartiestriangle
    a = (b * sin(α))/sin(β)
    Где:
    b - известная сторона
    α - угол противолежащий от стороны a и прилежащий к стороне b.
    β - угол противолежащий от стороны b и прилежащий к стороне a.
    """
    # math.sin ждёт угла в радианах, поэтому преобразуем градусы с помощью math.radians
    side_a = abs(side_b * math.sin(math.radians(angle_a))) / math.sin(math.radians(angle_b))
    return side_a

def f_drag_force (aerodynamic_coefficient, air_density, velocity, aerodynamic_square):
    """Аэродинамическое сопротивление.

    X=Ca*((p*V^2)/2)*S
    X — сопротивление в Ньютонах
    Cx — коэффициент аэродинамического сопротивления (0.04 для крыла)
    Cy - коэффициент подъёмной силы (зависит от угла атаки 5°=0.4, 9°=0.8, 15°=1.2)
    p — плотность воздуха в кг/м³ (1.2 при 20°C)
    V — скорость в м/с (50 м/с из прошлой формулы)
    S — площадь поперечного сечения (2 м²)
    """
    drag_force = aerodynamic_coefficient * ((air_density * velocity ** 2) / 2) * aerodynamic_square
    return drag_force

def f_reynolds_number (aircraft_speed, wingspan):
    """Число Рейнольдса. Если оно меньше критического - течение ламинарное.
    
    Формула:
    Re = (V * L) / (n / p)
    Где:
    V - скрость м/с
    L - хорда крыла
    n - динамическая вязкость воздуха (0.000018 Па*с при 20 °C)
    p - плотность воздуха (1.2 на уровне земли)
    Пример:
    ((100/3.6) * 0.35) / (0.000018 / 1.2) = 648 148
    """
    air_kinematic_viscosity = AIR_DYNAMIC_VISCOSITY / AIR_DENSITY
    reynolds_number = (aircraft_speed * wingspan) / air_kinematic_viscosity
    return reynolds_number

def f_wing_aspect_ratio (wingspan, wing_square):
    """Геометрическое удлинение крыла.
    
    L = l/b = l^2/S
    Где:
    l - размах крыла (длина прямой между крайними точками)
    b - средняя хорда крыла
    S - площадь крыла в м²
    """
    # Эта формула подходит только для прямых крыльев:
    wing_aspect_ratio = WINGSPAN / WING_WIDTH
    # А эта не работает для бипланов/трипланов:
    #wing_aspect_ratio = WINGSPAN ** 2 / WING_SQUARE
    return wing_aspect_ratio

def f_lift_induced_drag (wing_lift_coefficient, wing_aspect_ratio):
    """Индуктивное лобовое сопротивление.

    Формула индуктивного сопротивления:
    Cxi = Cy/(1.4*L)
    Где:
    Cxi - коэффициент индуктивного сопротивления
    Cy - коэффициент подъёмной силы (зависит от угла атаки 5°=0.4, 9°=0.8, 15°=1.2)
    L - геометрическое удлинение крыла (6.4)
    """
    lift_induced_drag = abs(wing_lift_coefficient / (1.4 * wing_aspect_ratio))
    return lift_induced_drag

def f_aerodynamic (angle_of_attack):
    """Аэродинамические показатели меняются со сменой угла атаки.
    
    1) Площадь фронтальной проекции зависит от наклона.
    2) Коэффициенты подъёмной силы и сопротивления крыла берутся из поляры.
    2) Коэффициент индуктивного сопротивления зависит от размаха и площади крыла.
    """
    # Фронтальная проекция зависит от угла атаки:
    if f_triangle(WING_WIDTH, angle_of_attack, 90) > WING_THICKNESS:
        wing_front_square = WINGSPAN * f_triangle(WING_WIDTH, angle_of_attack, 90)
        body_front_square = BODY_FRONT_SQUARE + BODY_WIDTH * f_triangle(BODY_LENGTH, angle_of_attack, 90)
    else:
        wing_front_square = WINGSPAN * WING_THICKNESS
        body_front_square = BODY_FRONT_SQUARE
    # Вычисляем общую фронтальную поверхность:
    total_front_square = wing_front_square + body_front_square
    # Коэффициенты подъёмной силы и лобового сопротивления крыла берём из таблицы: 
    wing_lift_coefficient = d_polar.get(angle_of_attack)[0]
    wing_drag = d_polar.get(angle_of_attack)[1]
    # Вычисляем общий коэффициент лобового сопротивления:
    wing_square_percent = wing_front_square / total_front_square
    body_square_percent = body_front_square / total_front_square
    front_aerodynamic = wing_drag * wing_square_percent + BODY_DRAG * body_square_percent
    # Считаем коэффициент индуктивного сопротивления (для дисколёта он значительной снижается):
    if DISK_WING is False:
        lift_induced_drag = f_lift_induced_drag(wing_lift_coefficient,
                f_wing_aspect_ratio(WINGSPAN, WING_SQUARE))
        # Коэффициент общего лобового сопротивления:
        total_front_aerodynamic = front_aerodynamic + lift_induced_drag
    else:
        total_front_aerodynamic = front_aerodynamic
    aerodynamic_output = (total_front_square, wing_front_square, wing_lift_coefficient, total_front_aerodynamic)
    return aerodynamic_output

def f_heated_gas_pressure (heat):
    """Уравнение состояния идеального газа.
    
    p=((m/M)*R*T)/V
    Где:
    p — Давление (в Паскалях).
    m — масса (1.2 кг).
    M — Молярная масса (для воздуха 0.029 кг/моль)
    R — Универсальная газовая постоянная (8.3145 Дж/(моль*К)
    T — Абсолютная температура (581 кельвин = 314 °C).
    V — Объём (1 м³).

    Газ расширяется при нагревании:
    ((1.2/0.02898)*8.3145*581)/1=200030
    """
    heated_gas_pressure = ((AIR_DENSITY / AIR_MOLAR_MASS) * GAS_CONSTANT * heat) / 1
    return heated_gas_pressure

def f_de_laval_nozzle (engine_air_heat, engine_air_pressure, atmospheric_pressure):
    """Формула сопла Лаваля определяет скорость реактивной струи по сжатию и нагреву рабочего вещества:
    
    Формула сопла Лаваля:
    https://ru.wikipedia.org/wiki/Сопло_Лаваля
    V=sqrt((T*R/M)*(2*k/(k-1))*[1-(Pe/p)^((k-1)/k)])
    Где:
    sqrt( ) — квадратный корень.
    V — Скорость газа на выходе из сопла, м/с
    T — Абсолютная температура газа на входе (в кельвинах). Возьмём 539 Кельвинов (267°C).
    R — Универсальная газовая постоянная (8.3145 Дж/(моль*К)
    M — Молярная масса газа, кг/киломоль (для воздуха 0.029 кг/моль)
    k — Показатель адиабаты (для сухого воздуха при 20°C — 1.4)
    [ ] — модуль
    Pe — Давление газа на выходе из сопла (в Паскалях). Атмосферное давление — 101 325 Паскалей.
    P — Давление газа на входе в сопло. Возьмём 2 Бара (200 000 Паскалей).

    Пример:
    math.sqrt((539 * 8.3144598 / 0.029) * (2 * 1.4 / (1.4 - 1)) * math.fabs(1 - (101325 / 200000) ** ((1.4 - 1) / 1.4)))
    При температуре сжатого воздуха 267°С и сжатии в 2 Бара скорость струи — 437 м/с.
    Для сравнения: скорость звука — 340.29 м/с
    """
    reactive_speed = math.sqrt((engine_air_heat * GAS_CONSTANT / AIR_MOLAR_MASS) * \
            (2 * AIR_HEAT_CAPACITY_RATIO / (AIR_HEAT_CAPACITY_RATIO - 1)) * \
            math.fabs(1 - (atmospheric_pressure / engine_air_pressure) ** \
            ((AIR_HEAT_CAPACITY_RATIO - 1) / AIR_HEAT_CAPACITY_RATIO)))
    return reactive_speed

def f_jet_force (working_mass, reactive_speed):
    """Тяга летательного аппарата."""
    max_engine_thrust = working_mass * reactive_speed
    return max_engine_thrust

def f_airflow (aircraft_speed, wing_square):
    """Объём воздуха, через который проходят крылья пегаса за секунду.
    
    Часть из этого воздуха использует воздушно-реактивный двигатель.
    А также из воздуха пони собирают энергию для полёта.
    """
    air_volume = aircraft_speed * wing_square * AIRFLOW_EFFICIENCY
    return air_volume

def f_engine (air_volume, energy_MJ):
    """Прямоточный воздушно реактивный двигатель.
    
    Набегающий поток воздуха попадает в нагреватель, где расширяется,
    А затем выбрасывается из сопла реактивной струёй.
    """
    # Рабочее вещество, это атмосферный воздух:
    working_mass = air_volume * AIR_DENSITY
    # Делим энергию на полезную и бесполезную:
    useful_energy_MJ = energy_MJ * ENGINE_EFFICIENCY
    useless_energy_MJ = energy_MJ - useful_energy_MJ
    useful_energy_KJ = useful_energy_MJ * 1000
    # Полезную энергию пускаем на разогрев воздуха:
    working_mass_heat = AIR_HEAT_CAPACITY * useful_energy_KJ / working_mass
    # Делаем поправку на температуру воздуха и переводим градусы в шкалу Кельвина:
    working_mass_heat = AIR_TEMPERATURE + working_mass_heat + KELVIN_SCALE
    # Давление разогретого воздуха увеличивается:
    working_mass_pressure = f_heated_gas_pressure(working_mass_heat)
    # Воздух подаётся на сопло Лаваля, так мы получаем скорость реактивной струи:
    reactive_speed = f_de_laval_nozzle(working_mass_heat,
            working_mass_pressure, ATMOSPHERIC_PRESSURE)
    # Максимальная тяга, это масса рабочего вещества умноженная на его скорость:
    max_engine_thrust = f_jet_force(working_mass, reactive_speed)
    # Бесполезную тепловую энергию тоже требуется куда-то отводить:
    engine_output = (max_engine_thrust, working_mass, reactive_speed, useless_energy_MJ)
    return engine_output

def f_engine_control (engine_mode, air_volume=START_AIR_VOLUME):
    """Режимы работы двигателя."""
    # Аслоу, эта функция должна следить за временем.
    # А нужно ли это? Нужно, чтобы определить тягу под каждый режим, а потом пользоваться как таблицей.
    # Тогда понадобится и воздушный поток брать, и поверхность крыльев. Модель в модели, зачем она?
    energy_unit = WINGPOWER
    working_mass_energy = WORKING_MASS_ENERGY_MJ
    energy_scale = working_mass_energy  / energy_unit
    d_engine = {
            'dash':(energy_scale, working_mass_energy),
            'maximal':(energy_scale / 2, working_mass_energy / 2),
            'nominal':(energy_scale / 4, working_mass_energy / 4),
            'cruising':(energy_scale / 8, working_mass_energy / 8),
            'minimal':(energy_scale / 16, working_mass_energy / 16),
            'shy':(energy_scale / 32, working_mass_energy / 32),
            }
    # Привяжи тогда уж контрольную панель к самому двигателю:
    engine_output = f_engine(air_volume, d_engine[engine_mode][1])
    engine_required_energy = d_engine[engine_mode][1]
    engine_thrust = engine_output[0]
    engine_overheating = engine_output[3]
    # Можно добавить систему охлаждения и ограничение на длительность форсажа.
    return engine_thrust, engine_required_energy, engine_overheating

def f_engine_mode_choice (required_thrust, engine_air_volume):
    """Выбор режима двигателя. Тупым перебором."""
    engine_modes = ['shy', 'minimal', 'cruising', 'nominal', 'maximal', 'dash']
    optimal_mode = None
    for mode in engine_modes:
        engine_thrust, engine_required_energy, engine_overheating = \
                f_engine_control(mode, engine_air_volume)
        if engine_thrust > required_thrust:
            optimal_mode = engine_thrust, engine_required_energy, engine_overheating, mode
            break
    # Если ни один режим не даёт достаточной тяги, тогда всё равно выбираем форсаж:
    if optimal_mode is None:
        mode = 'dash'
        engine_thrust, engine_required_energy, engine_overheating = \
                f_engine_control(mode, engine_air_volume)
        optimal_mode = engine_thrust, engine_required_energy, engine_overheating, mode
    return optimal_mode

def f_rolling (grav_force, lift_force, drag_force,
        aircraft_mass, aircraft_speed):
    """Качение по взлётной полосе.

    Подъёмной силы недостаточно для взлёта, хотя вес и уменьшается.
    Замедление из-за лобового сопротивления и силы трения качения.

    Формула силы трения качения:
    Fтр=kтр(Fn/r)
    Где:
    kтр- коэффициент трения
    Fn - прижимающая сила
    r - радиус колеса."""
    # По взлётной полосе пони может бежать со скоростью в 10 м/с
    # Но в данном случаем мы попросту катимся на колёсиках.
    if lift_force > 0:
        normal_force = grav_force - lift_force
    else:
        normal_force = grav_force + abs(lift_force)
    # Замедление из-за аэродинамического сопротивления:
    drag_deceleration = drag_force / aircraft_mass
    # Работает сила трения качения (поскольку копыта считать лень):
    friction_force = ROLLING_RESISTANCE_COEFFICIENT * \
            (normal_force / WHEEL_RADIUS)
    #print(drag_force, friction_force)
    friction_deceleration = friction_force / aircraft_mass
    rolling_deceleration = drag_deceleration + friction_deceleration
    aircraft_speed = aircraft_speed - rolling_deceleration
    return aircraft_speed

def f_climbing (grav_force, lift_force, drag_force,
        aircraft_mass, aircraft_speed, angle_of_attack, climb_speed):
    """Набор высоты за счёт подъёмной силы и угла вектора скорости.
    
    Чем выше подъёмная сила, тем с большим ускорением пегаса тащит вверх.
    Также набранная высота повышается из-за вектора скорости к горизонту.
    """
    drag_deceleration = drag_force / aircraft_mass
    aircraft_speed = aircraft_speed - drag_deceleration
    # Подъёмная сила выше силы притяжения, крыло тащит пегаса вверх:
    climb_force = lift_force - grav_force
    climb_acceleration = climb_force / aircraft_mass
    climb_speed = climb_speed + climb_acceleration
    # Также на высоту работает направление вектора скорости:
    climb_rate = climb_speed + \
            f_triangle(aircraft_speed, angle_of_attack, 90)
    return aircraft_speed, climb_speed, climb_rate

def f_descenting (grav_force, lift_force, drag_force,
        aircraft_mass, aircraft_speed, angle_of_attack, climb_speed):
    """Сваливание.
    
    Угол атаки положительный, но скорость подъёма падает,
    Достигает нуля и переходит в скорость падения.
    При этом скорсть падения -- векторная, минусовая величина.
    """
    # Ты не учитываешь сопротивление воздуха при падении.
    # Средний пегас должен падать со скоростью в 190-240 км/час.
    # При такой скорости лобовое сопротивление 213 ньютонов.

    drag_deceleration = drag_force / aircraft_mass
    aircraft_speed = aircraft_speed - drag_deceleration
    descent_force = grav_force - lift_force
    # Хм, нужно будет вычислить аэродинамику для проекции снизу.
    # Можно исходить из коэффициента подъёмной силы крыла.
    #print('lift_force',lift_force)

    descent_acceleration = descent_force / aircraft_mass
    # Потеря высоты из за нехватки подъёмной силы:
    climb_speed = climb_speed - descent_acceleration
    # Вектор скорости уменьшает потерю высоты:
    climb_rate = climb_speed + \
            f_triangle(aircraft_speed, angle_of_attack, 90)
    return aircraft_speed, climb_speed, climb_rate

def f_diving (grav_force, lift_force, drag_force,
        aircraft_mass, aircraft_speed, angle_of_attack, climb_speed):
    """Пикирование.

    Угол атаки отрицательный, подъёмная сила превращается в силу антикрыла.
    По этой же причине вектор прижимающей силы отклоняется вперёд.
    Доля прижимающей силы (синус угла атаки) переходит в силу тяги.
    Аппарат платит набранной высотой за быстрое повышение скорости.
    """
    descent_force = -grav_force + lift_force
    descent_acceleration = descent_force / aircraft_mass
    # Скорость снижения минусовая:
    descent_speed = climb_speed + descent_acceleration
    # Крыло скользит по воздуху под углом, поэтому вектор силы реакции опоры отклоняется вперёд.
    # Часть силы притяжения и давления воздуха на крыло переходит в силу тяги:
    incline_force = abs(descent_force * math.sin(math.radians(angle_of_attack)))
    incline_force = incline_force - drag_force
    incline_acceleration = incline_force / aircraft_mass
    aircraft_speed = aircraft_speed + incline_acceleration
    #print(descent_force,incline_force,descent_acceleration,incline_acceleration)
    # Вектор скорости летательного аппарата направлен под углом к земле:
    descent_rate = descent_speed + f_triangle(aircraft_speed, angle_of_attack, 90)
    return aircraft_speed, descent_speed, descent_rate

def f_gliding (grav_force, lift_force, drag_force,
        aircraft_mass, aircraft_speed, angle_of_attack, climb_speed):
    """Планирование.
    
    Угол атаки отрицательный, но подъёмная сила поддерживает аппарат.
    Вектор прижимающей силы незначительно отклоняется вперёд.
    Доля прижимающей силы (синус угла атаки) переходит в силу тяги.
    Аппарат компенсирует лобовое сопротивление за счёт медленного снижения.
    """
    # На самом деле очень уродливая функция. Обязательно перепиши!
    ## Подъёмная сила выше силы притяжения, крыло тащит пегаса вверх:
    climb_force = lift_force - grav_force
    climb_acceleration = climb_force / aircraft_mass
    climb_speed = climb_speed + climb_acceleration
    #print('nya', climb_force, climb_speed)
    # Вектор прижимаюещей силы направлен вперёд, поэтому часть её переходит в тягу.
    # Тяга незначительная, но всё же работает против сопротивления воздуха.
    incline_force = abs(grav_force * math.sin(math.radians(angle_of_attack)))
    drag_force = drag_force - incline_force
    # Так не бывает, но всё же учтём.
    if drag_force < 0:
        print('С профилем крыла что-то не так. f_gliding', drag_force)
        incline_force = abs(drag_force)
        incline_acceleration = incline_force / aircraft_mass
        aircraft_speed = aircraft_speed + incline_acceleration
    else:
        drag_deceleration = drag_force / aircraft_mass
        aircraft_speed = aircraft_speed - drag_deceleration
    # Плата за планирование -- снижение под небольшим углом:
    descent_rate = f_triangle(aircraft_speed, angle_of_attack, 90)
    if climb_speed > 0:
        climb_rate = climb_speed - descent_rate
        return aircraft_speed, climb_speed, climb_rate
    else:
        descent_rate = descent_rate + climb_speed
        return aircraft_speed, climb_speed, descent_rate

def f_glide_model (aircraft_mass, aircraft_speed=0, angle_of_attack=0, altitude=0, silent=False):
    """Модель планирования."""
    # Аэродинамические свойства зависят от угла атаки:
    total_front_square, wing_front_square, \
            wing_lift_coefficient, total_front_aerodynamic = f_aerodynamic(angle_of_attack)
    grav_force = aircraft_mass * GRAVITATIONAL_ACCELERATION
    d_LD_ratio = f_lift_to_drag_ratio(d_polar)
    engine_air_volume = f_airflow(aircraft_speed, wing_front_square)
    # Словарь для вывода данных:
    d_flight = {}
    # Приборная панель:
    # Добавь данные о массе аппарата. Ведь всё относительно в мире том.
    d_glide = {
            'engine_air_volume':engine_air_volume,
            'aircraft_speed':aircraft_speed,
            'climb_speed':0,
            'altitude':altitude,
            'path':0,
            'second':0,
            }
    energy_balance = ENERGY_BALANCE_MJ
    # Пока что считаем цикл по секундам, а надо бы по доступной энергии, скорости и высоте:
    while d_glide['second'] < PERIOD_SECOND:
        # Берём данные из словаря:
        second = d_glide['second']
        aircraft_speed = d_glide['aircraft_speed']
        climb_speed = d_glide['climb_speed']
        altitude = d_glide['altitude']
        path = d_glide['path']
        # Автопилот (пока не работает):
        optimum_angle, engine_thrust, engine_required_energy = \
                f_pegasus_mind(d_glide, d_LD_ratio, aircraft_mass, energy_balance)
        #print(optimum_angle,engine_thrust,engine_required_energy)
        # Алсо, фронтальную поверхность крыльев тоже нужно занести в словарь (или сразу airflow):
        total_front_square, wing_front_square, \
                wing_lift_coefficient, total_front_aerodynamic = f_aerodynamic(optimum_angle)
        # Вычисляем секундное ускорение:
        jet_acceleration = engine_thrust / aircraft_mass
        aircraft_speed = aircraft_speed + jet_acceleration
        # Вычисляем объём рабочего вещества для ВРД:
        engine_air_volume = f_airflow(aircraft_speed, wing_front_square)
        # Считаем подъёмную силу и лобовое сопротивление:
        drag_force = f_drag_force(total_front_aerodynamic,AIR_DENSITY,aircraft_speed,total_front_square)
        lift_force = f_drag_force(wing_lift_coefficient,AIR_DENSITY,aircraft_speed,WING_SQUARE)
        lift_force_kilogram = lift_force / GRAVITATIONAL_ACCELERATION
        # Качение по земле:
        if altitude == 0 and climb_speed == 0 and lift_force < grav_force:
            aircraft_speed = f_rolling(grav_force, lift_force, drag_force,
                    aircraft_mass, aircraft_speed)
            distance = aircraft_speed
            climb_rate = 0
        # Набор высоты:
        elif angle_of_attack > 0 and lift_force > grav_force:
            aircraft_speed, climb_speed, climb_rate = f_climbing(grav_force, lift_force, drag_force,
                    aircraft_mass, aircraft_speed, angle_of_attack, climb_speed)
            # Скорость, это векторная величина,
            # А расстояние по горизонтали -- соседняя сторона треугольника:
            distance = f_triangle(aircraft_speed, 90 - angle_of_attack, 90)
        # Сваливание:
        elif angle_of_attack > 0 and lift_force < grav_force and lift_force > 0:
            aircraft_speed, climb_speed, climb_rate = f_descenting(grav_force, lift_force, drag_force,
                    aircraft_mass, aircraft_speed, angle_of_attack, climb_speed)
            distance = f_triangle(aircraft_speed, 90 - angle_of_attack, 90)
        ## Пикирование:
        elif angle_of_attack < 0 and lift_force < grav_force:
            aircraft_speed, climb_speed, climb_rate = f_diving(grav_force, lift_force, drag_force,
                    aircraft_mass, aircraft_speed, angle_of_attack, climb_speed)
            distance = f_triangle(aircraft_speed, 90 - angle_of_attack, 90)
        ## Планирование:
        elif angle_of_attack < 0 and lift_force > grav_force:
            aircraft_speed, climb_speed, climb_rate = f_gliding(grav_force, lift_force, drag_force,
                    aircraft_mass, aircraft_speed, angle_of_attack, climb_speed)
            distance = f_triangle(aircraft_speed, 90 - angle_of_attack, 90)
        else:
            print('Что-то пошло не так. glide_model')
            #print(lift_force, drag_force, lift_force_kilogram)
        # Считаем модель пока пони не приземлится или не остановится.
        if d_glide['altitude'] < 0:
            print('Приземление')
            break
        elif aircraft_speed <= 0:
            print('Остановка')
            break
        # Добавляем данные в словарь:
        d_glide['engine_air_volume'] = engine_air_volume
        d_glide['aircraft_speed'] = aircraft_speed
        d_glide['climb_speed'] = climb_speed
        d_glide['altitude'] = d_glide['altitude'] + climb_rate
        d_glide['path'] = d_glide['path'] + distance
        # Переходим к следующему циклу:
        d_glide['second'] += 1
        # Данные сохраняются для вывода:
        speed_kilometre_hour = aircraft_speed * 3.6
        if silent is not True:
            print(round(aircraft_speed),round(path),round(altitude),round(engine_required_energy * 1000), 'kWt')
        d_flight[second] = (speed_kilometre_hour, drag_force, lift_force_kilogram,
                second, path, altitude)
    # В вывод идут данные цикла до момента сваливания.
    # Ну и зачем нужен этот вывод?
    if d_flight:
        glide_output = d_flight[len(d_flight) - 1]
        return glide_output

def f_lift_to_drag_ratio (d_polar):
    """Аэродинамическое качество, это Cy/Cx (Cl/Cd)
    
    Следует заметить, что при этом нас интересует не Cl/Cd крыла,
    А тот же показатель для всего аппарата.
    """
    d_LD_ratio = {}
    for key in d_polar:
        Cl = d_polar[key][0]
        total_front_aerodynamic = f_aerodynamic(key)[3]
        LD_ratio = Cl / total_front_aerodynamic
        d_LD_ratio[key] = LD_ratio
    return d_LD_ratio

def f_acceleration_estimate (speed, distance):
    """Определяем необходимое ускорение по конечной скорости и дистанции
    
    Формула для определения пути без знания времени:
    S = (V ** 2 - V0 ** 2) / 2 * a
    Где:
    S - расстояние
    V - скорость
    V0 - начальная скорость
    a - ускорение

    Выведенная формула:
    a = (V ** 2) / S / 2
    Где:
    V - скорость
    S - расстояние
    a - ускорение
    """
    acceleration = (speed ** 2) / distance / 2
    return acceleration

def f_autopilot_takeoff (d_glide, d_LD_ratio, aircraft_mass, energy_balance):
    """Процедура взлёта.

    1) Автопилот выбирает оптимальный угол атаки по аэродинамическому качеству.
    2) Выбирается взлётная скорость по углу атаки и весу аппарата.
    3) Выбирается ускорение, ограниченное длиной взлётной полосы.
    4) По ускорению и аэродинамическому качеству определяется необходимая тяга.
    5) Наконец, выбирается оптимальный режим двигателя (простым перебором).
    """
    engine_air_volume = d_glide['engine_air_volume']
    aircraft_speed = d_glide['aircraft_speed']
    optimum_angle = max(d_LD_ratio.keys(), key=(lambda k: d_LD_ratio[k]))
    optimum_speed = f_find_optimum_speed_for_angle(aircraft_mass, optimum_angle)
    optimum_acceleration = f_acceleration_estimate(optimum_speed, RUNWAY_LENGTH)
    optimum_trust = optimum_acceleration * aircraft_mass
    # Вычислем необходимую тягу через коэффициент аэродинамического качества:
    required_thrust = (aircraft_mass * GRAVITATIONAL_ACCELERATION) / d_LD_ratio[optimum_angle]
    # КПД понячьего двигателя зависит от скорости, лучше взять максимальное ускорение в начале:
    if engine_air_volume == 0:
        engine_mode = 'maximal'
        engine_thrust, engine_required_energy, engine_overheating = \
                f_engine_control(engine_mode, START_AIR_VOLUME)
        return optimum_angle, engine_thrust, engine_required_energy
    # Если взлётная полоса достаточно длинная, не мучаем двигатель:
    elif required_thrust > optimum_trust:
        engine_thrust, engine_required_energy, engine_overheating, engine_mode = \
                f_engine_mode_choice (required_thrust, engine_air_volume)
        #print(engine_mode)
        return optimum_angle, engine_thrust, engine_required_energy
    # Если длина взлётной полосы недостаточна, увеличиваем тягу:
    elif required_thrust < optimum_trust:
        required_thrust = optimum_trust
        engine_thrust, engine_required_energy, engine_overheating, engine_mode = \
                f_engine_mode_choice (required_thrust, engine_air_volume)
        #print(engine_mode)
        return optimum_angle, engine_thrust, engine_required_energy
    else:
        #print('Что-то пошло не так. f_autopilot_takeoff:')
        return optimum_angle, 0, 0

def f_pegasus_mind (d_glide, d_LD_ratio, aircraft_mass, energy_balance):
    # Потихоньку пишем пегасий ИИ. Он должен передавать команды крыльям и движку.
    second = d_glide['second']
    engine_air_volume = d_glide['engine_air_volume']
    aircraft_speed = d_glide['aircraft_speed']
    climb_speed = d_glide['climb_speed']
    altitude = d_glide['altitude']
    path = d_glide['path']
    # Взлёт:
    if altitude == 0:
        optimum_angle, engine_thrust, engine_required_energy = \
                f_autopilot_takeoff(d_glide, d_LD_ratio, aircraft_mass, energy_balance)
        return optimum_angle, engine_thrust, engine_required_energy
    # Полёт с набором высоты:
    elif 0 < altitude < 1000 and climb_speed > 0:
        # А вот и нет, здесь оптимальный угол уже ищется по лобовому сопротивлению.
        # Но сразу не выбирается, чтобы подъёмная сила не упала.
        optimum_angle = max(d_LD_ratio.keys(), key=(lambda k: d_LD_ratio[k]))
        optimum_speed = f_find_optimum_speed_for_angle(aircraft_mass, optimum_angle)
        if aircraft_speed < optimum_speed:
            required_thrust = (aircraft_mass * GRAVITATIONAL_ACCELERATION) / d_LD_ratio[optimum_angle]
            engine_thrust, engine_required_energy, engine_overheating, engine_mode = \
                    f_engine_mode_choice (required_thrust, engine_air_volume)
            #print(engine_mode)
            return optimum_angle, engine_thrust, engine_required_energy
        if aircraft_speed >= optimum_speed:
            #print('off')
            return optimum_angle, 0, 0
    elif 0 < altitude < 1000 and climb_speed < 0:
    # Боремся со сваливанием:
    # Нужно считать скорость сваливания и расстояние до земли, а потом выбирать оптимальную тягу.
    # Сейчас проблема не в автопилоте, а в самом процессе сваливания.
    # Сопротивление воздуха учитывается только для фронтальной проекции.
        optimum_angle = max(d_LD_ratio.keys(), key=(lambda k: d_LD_ratio[k]))
        engine_mode = 'maximal'
        #print(engine_mode, climb_speed)
        engine_thrust, engine_required_energy, engine_overheating = \
                f_engine_control(engine_mode, START_AIR_VOLUME)
        return optimum_angle, engine_thrust, engine_required_energy

    # Планирование:
    elif altitude > 1000:
        #print('off')
        optimum_angle = max(d_LD_ratio.keys(), key=(lambda k: d_LD_ratio[k]))
        return optimum_angle, 0, 0



    else:
        print('Автопилот не умеет летать.')
        optimum_angle = max(d_LD_ratio.keys(), key=(lambda k: d_LD_ratio[k]))
        return optimum_angle, 0, 0



def f_flight_model (speed):
    """Модель полёта с постоянной скоростью."""
    # Старая глупая модель. Перепели её!
    # Аэродинамические свойства зависят от угла атаки:
    total_front_square, wing_front_square, \
            wing_lift_coefficient, total_front_aerodynamic = f_aerodynamic(angle_of_attack)
    speed_kilometre_hour = speed
    speed_metre_second = speed / 3.6
    aircraft_speed = speed_metre_second
    second = 1
    path = 0
    altitude = 0
    engine_cycles = 1
    # Возможности двигателя:
    max_engine_thrust, working_mass, reactive_speed = f_engine(AIR_VOLUME, WORKING_MASS_ENERGY_MJ)[0:3]
    working_mass_balance = working_mass
    energy_balance = ENERGY_BALANCE_MJ
    # Этот цикл сильно замедляет программу. Но пони собирает энергию в полёте, а плотность воздуха падает.
    while energy_balance > WORKING_MASS_ENERGY_MJ:
        drag_force = f_drag_force(total_front_aerodynamic,AIR_DENSITY,speed_metre_second,total_front_square)
        lift_force = f_drag_force(wing_lift_coefficient,AIR_DENSITY,speed_metre_second,WING_SQUARE)
        lift_force_kilogram = lift_force / GRAVITATIONAL_ACCELERATION
        # Расход рабочего вещества за секунду полёта:
        working_mass_consumpion = drag_force / reactive_speed
        working_mass_balance -= working_mass_consumpion
        # Если рабочее вещество кончается, пополняем новым циклом:
        if working_mass_balance < 0:
            working_mass_balance += working_mass
            energy_balance -= WORKING_MASS_ENERGY_MJ
            engine_cycles += 1
        # В ходе полёта пополняем энергию (за счёт всей фронтальной поверхности тела):
        air_volume = total_front_square * aircraft_speed
        energy_collection = air_volume * AIR_MAGIC_ENERGY_MJ
        if namespace.energy is True:
            energy_balance += energy_collection
        # Пройденный путь:
        distance = f_triangle(aircraft_speed, 90 - angle_of_attack, 90)
        path = path + distance
        # Скороподъёмность:
        climb_rate = f_triangle(aircraft_speed, angle_of_attack, 90)
        # Набранная высота:
        altitude = altitude + climb_rate
        if aircraft_mass > lift_force_kilogram:
            #print('Сваливание.')
            break
        second += 1
    # Промежуток между циклами двигателя:
    cycle_period = second / engine_cycles
    flight_output = (
            round(speed_kilometre_hour), round(drag_force), round(lift_force_kilogram),
            second, round(path), round(altitude), engine_cycles, round(cycle_period),
            )
    return flight_output

def f_find_optimum_speed_for_angle (aircraft_mass, angle_of_attack):
    """Взлётная скорость для определённого угла.

    Выведенная из уравнения аэродинамики формула:
    V = sqrt((2 * m * g) / (Cy * p * S))
    Где:
    V - скорость в м/с
    m - масса летательного аппарата в килограммах
    g - ускорение свободного падения (9.81 м/с²)
    Cy - коэффициент подъёмной силы
    p - плотность воздуха в кг/м³ (1.2 при 20°C)
    S - площадь поперечного сечения в м²
    """
    # Надо бы коэффициент подъёмной силы брать на входе скрипта:
    wing_lift_coefficient = d_polar.get(angle_of_attack)[0]
    optimum_speed = math.sqrt((2 * aircraft_mass * GRAVITATIONAL_ACCELERATION) /
            (wing_lift_coefficient * AIR_DENSITY * WING_SQUARE))
    return optimum_speed

def f_find_optimum_speed (max_speed):
    """Оптимальные значения скорости для определённого угла."""
    # Вообще-то это вычисляется простой формулой.
    # Скорость через коэффициент аэродинамического качества:
    # V = sqrt((2 * m * g) / (Cy * p * S))
    # Где:
    # V - скорость в м/с
    # m - масса летательного аппарата в килограммах
    # g - ускорение свободного падения (9.81 м/с²)
    # Cy - коэффициент подъёмной силы
    # p - плотность воздуха в кг/м³ (1.2 при 20°C)
    # S - площадь поперечного сечения в м²

    # А вот эта фигня не нужна:
    speed = 0
    d_test_model = {}
    while speed < max_speed:
        key = speed
        d_test_model[key] = f_flight_model(speed)
        speed += 1
    optimum_speed = max(d_test_model.keys(), key=(lambda k: d_test_model[k][4]))
    #max_distance_output = d_test_model[optimum_speed]
    return optimum_speed

#-------------------------------------------------------------------------
# Встроенный поисковик:

# Создаётся список аргументов скрипта:
parser = create_parser()
namespace = parser.parse_args()

# Проверка, введено ли название летательного аппарата:
if namespace.sample:
    sample = ' '.join(namespace.sample)
else:
    # Если нет, берём стандартный:
    sample = SAMPLE

# Если название неточное, срабатывает встроенный поисковик:
if sample not in d_samples.keys():
    sample = key_search(sample, d_samples, silent=False)
    print('Выбрано:', sample)
    #print(d_samples[sample])

#-------------------------------------------------------------------------
# Рабочие переменные:

# Переменные двигателя:
AIRCRAFT_MASS = d_samples[sample]['Масса аппарата (килограмм)']
AIR_VOLUME = d_samples[sample]['Объём двигателя (кубометров)']
# Переменные аккумулятора:
ENERGY_BALANCE_MJ = d_samples[sample]['Запас энергии (мегаджоулей)']
WORKING_MASS_ENERGY_MJ = d_samples[sample]['Расход энергии (мегаджоулей)']
# Переменные планера (пегас на собственных крыльях):
WING_FRONT_SQUARE = d_samples[sample]['Фронтальная площадь крыла (квадратных метров)']
BODY_FRONT_SQUARE = d_samples[sample]['Фронтальная площадь фюзеляжа (квадратных метров)']
BODY_DRAG = d_samples[sample]['Коэффициент лобового сопротивления фюзеляжа']
BODY_LENGTH = d_samples[sample]['Длина фюзеляжа (метров)']
BODY_WIDTH = d_samples[sample]['Ширина фюзеляжа (метров)']
WING_WIDTH = d_samples[sample]['Хорда крыла (метров)']
WING_THICKNESS = d_samples[sample]['Толщина крыла (метров)']
WINGSPAN = d_samples[sample]['Размах крыла (метров)']
WING_SQUARE = d_samples[sample]['Несущая площадь крыла (квадратных метров)']
WHEEL_RADIUS = d_samples[sample]['Радиус колеса шасси (метров)']

# Словарь соответствий углов атаки и коэффициентов аэродинамики крыла:
d_polar = d_samples[sample]['Поляра профиля крыла']

# Нестандартное крыло:
if d_samples[sample]['Дисколёт'] is True:
    DISK_WING = True
else:
    DISK_WING = False

#-------------------------------------------------------------------------
# Обработка аргументов командной строки:

# Проверка, указан ли угол атаки:
if namespace.angle:
    angle_of_attack = key_search(str(namespace.angle), d_polar, silent=False)
    angle_of_attack = float(angle_of_attack)
    print('Выбрано:', angle_of_attack)
else:
    # Если нет, мспользовать угол с минимальный лобовымм сопротивлением:
    angle_of_attack = min(d_polar.keys(), key=(lambda k: d_polar[k][1]))

# Проверка, указан ли вес груза:
if namespace.weight:
    aircraft_mass = namespace.weight
else:
    aircraft_mass = AIRCRAFT_MASS

# Проверка, указана ли скорость:
if namespace.speed:
    aircraft_speed = namespace.speed
else:
    aircraft_speed = 0

#-------------------------------------------------------------------------
# Тело программы:

# Проверка, указана ли постоянная скорость:
if namespace.speed:
    # Если да, смотрим, насколько она реальна:
    print('Полёт с постоянной скоростью')
    flight_output = f_flight_model(namespace.speed)
    print('Скорость (км/час), лобовое сопротивление (ньютонов), подъёмная сила (кгс)')
    print(flight_output[0:3])
    print('Время, путь, высота, циклы двигателя, между циклами (секунд)')
    print(flight_output[3:8])
elif namespace.model is True:
    # Если нет, проверяем все варианты и выбираем оптимальный по дальности:
    if namespace.angle is None:
        d_flight_angles = {}
        for key in d_polar:
            if key > 0:
                print('Поиск оптимальной скорости для угла атаки:', key)
                angle_of_attack = key
                d_flight_angles[key] = f_flight_model(f_find_optimum_speed(MAX_SPEED))
        optimum_angle = max(d_flight_angles.keys(), key=(lambda k: d_flight_angles[k][4]))
        optimum_output = d_flight_angles[optimum_angle]
        print('Полёт с оптимальной скоростью и углом атаки:',optimum_angle)
        print('Скорость (км/час), лобовое сопротивление (ньютонов), подъёмная сила (кгс)')
        print(optimum_output[0:3])
        print('Время, путь, высота, циклы двигателя, между циклами (секунд)')
        print(optimum_output[3:8])
    else:
        print('Полёт с оптимальной скоростью')
        flight_output = f_flight_model(f_find_optimum_speed(MAX_SPEED))
        print('Скорость (км/час), лобовое сопротивление (ньютонов), подъёмная сила (кгс)')
        print(flight_output[0:3])
        print('Время, путь, высота, циклы двигателя, между циклами (секунд)')
        print(flight_output[3:8])
else:
    # В ином случае моделируем взлёт с оптимальным (или указанным) углом атаки:
    if namespace.angle is None:
        # Поиск угла с максимальной подъёмной силой:
        optimum_angle = max(d_polar.keys(), key=(lambda k: d_polar[k][0]))
        angle_of_attack = optimum_angle
        print('Взлёт с углом атаки:',optimum_angle)
    else:
        print('Взлёт')
    # Хау, теперь осталось только добавить плавный разгон.
    # Один цикл двигателя:
    #max_engine_thrust, working_mass, reactive_speed = f_engine(AIR_VOLUME, WORKING_MASS_ENERGY_MJ)[0:3]
    # Пегас набирает предельную скорость за одну секунду (на самом деле очень крутой пегас):
    #aircraft_acceleration = max_engine_thrust / aircraft_mass
    # А вообще, здесь надо бы поставить ускорение и длину взлётной полосы.
    #aircraft_speed = aircraft_acceleration
    # Пегас взлетает и падает:
    print('Скорость (м/с), путь, высота, мощность (кВт)')
    glide_output = f_glide_model(aircraft_mass, aircraft_speed, angle_of_attack)
    ## Избавлемся от чисел после запятой:
    glide_output = [round(i) for i in glide_output]
    print('Скорость (км/ч), лобовое сопротивление (ньютонов), подъёмная сила (кгс)')
    print(glide_output[0:3])
    print('Время, путь, высота')
    print(glide_output[3:8])

# Мимолётные вычисления:
#print(f_reynolds_number(100/3.6,0.35))
#print(f_reynolds_number(200/3.6,0.35))

#print(f_engine(1.4, WORKING_MASS_ENERGY_MJ))
#print(f_engine(2.8, WORKING_MASS_ENERGY_MJ))
#print(f_engine(4.62, WORKING_MASS_ENERGY_MJ))
